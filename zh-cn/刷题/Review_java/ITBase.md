# 


- 在计算机系统中，数值一律用补码来表示（存储）
 - 正数：补码=反码=原码（当然以二进制形式表达）
- 29 int类型（4个字节）二进制： 00000000 00000000 00000000 10000001
- 普及一下：正数原码，反码，补码相同
- 负数反码除了符号位不变，其他位取反，补码=反码+1


- char一个简便的记忆法：0：48  A:65  a:97




### 逻辑运算:& |
- 1.与运算分为普通与（&）和短路与（&&）两种
    - ①&普通与：所有的判断条件都要判断.
    - ②&&短路与：如果前面的判断返回了false,那么后面不再判断，最终结果就是false.
    - username != null &&!username.equals("")，
      二者的顺序不能交换，更不能用&运算符，
      因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常
- 2.或运算分为普通或（|）和短路（||）或两种
    - ①|普通或：所有的判断条件都要判断.
    - ②||短路或：如果前面的判断返回了true,那么后面不再判断，最终结果就是true.



- 解释为什么会出现4.0-3.6=0.40000001这种现象？
- 2进制的小数无法精确的表达10进制小数，计算机在计算10进制小数的过程中要先转换为2进制进行计算，这个过程中出现了误差。
  - 0.5能够表示，因为它可以表示成为1/2
    0.75也能够表示，因为它可以表示成为1/2+1/(2^2)
    0.875也能够表示，因为它可以表示成为1/2+1/(2^2)+1/(2^3)
    0.9375也能够表示，因为它可以表示成为1/2+1/(2^2)+1/(2^3)+1/(2^4)
  - 但是0.1不能够精确表示，因为它不能表示成为1/(2^n)的和的形式

- 解决:如果在数值计算中不允许有任何舍入误差， 就应该使用 BigDecimal类。






