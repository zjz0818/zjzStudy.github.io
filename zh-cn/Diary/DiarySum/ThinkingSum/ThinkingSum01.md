 # 总结
 
## 偶尔的日结
### 20211115做PAT心得
> 1.做的intCut,用到了很多方法,涉及--,
- 大的字符串切割 subString--源于发现,字符串的length..手动输入较长的整数,不通过..int,long是有固定长度的
- switch的使用;case X:-----之后要break;
- 返回类型可以是List,Set,Map,Stack等等...  
- 迭代器的使用,集合.iterator.hasNext()
   
> 2.做的按照年龄排对象
- 直接使用bean存对象
- 使用数组存bean
- 存入时进行比较就好了,记编号就好了.
- 思考:如果要排序咋整...如果直接使用Arrays.sort,,直接写个java类,实现Comparator
 - 如果要使用自己的排序方式,如快排,,,怎么整?  正常排序是比较的是数组中的每个元素
 - 而这个比较的是数组中的对象的属性.在编写排序时做手脚




### 20211116做PAT心得
> 1.做的数组的右移
- 主要是要学会`卡点`,即这次循环交换完,要不要**重置这个值**,在内for的外面进行编写,回值

> 2.做的素数
- 素数:除自己和1之外都不可除,使用的是取余的方式进行判断
- 取余:取余成功则是0,失败则是非0
  - 取余中需要注意的是:例如10%10是0,而它的末位是9,也就是从0--9 没有10的,切记...

> 3.做的一个涉及Ascii码的
- 主要直接使用`'A'` 这个直接表示就好了,不用专门找多少号
- 如果非要知道,直接运行下 'A'-0  就是直接跑下字符减去0就是对应的值
- 随后做了一个统计0-9的次数,也是直接使用Ascii码直接计算差值,然后整就行
- 对于Ascii的处理,或者说`字符串`中`数字的处理`,直接num+'0'就好'


### 20211117做PAT心得
> 1.做划拳
- 主要是要注意扣字眼,比如这个:输的人喝酒,然后代码求的是赢,反正最后要判断好

> 2.做螺旋矩阵--这个卡了我18号一天..
- 矩阵是M*N,要求M-N最小的组合
- 1.涉及到**整数的判断**,然后依据开平发(Math.sqrt())找到最近的值,此时想象数轴
  - 主要是要注意判断是不是Int类型..方法--((double)a)/b==a/b
- 2.涉及到**二维数组**的行数,列数
  - 二维数组的`arr[行数][列数]`
- 3.涉及到**sort的判定**,它基本类型只能一个参数,对象类型可以前面写参数,后面补规则
  - 如逆序输出(Arrays.sort(Integer[],Collections.reverseOrder());) -- 也可以手动编写
  - 值得注意的是,后面那个参数要的是`方法`,或者是`构造器`
- 4.涉及到对于矩阵的调整,我直接对应XOY坐标,将X的首尾x1,x2---Y的首尾y1,y2,,方便控制方向
  - 值得注意的是,以后的for最好`条件设置成可等于的`,对于for里面的表达式很友好
- 5.涉及到while,while是一个整体,只能加break跳出,要不就走完一轮再说...



### 20211129做PAT心得
> Error
- 在字符串的输入时,发现,如果你之前输入的不是nextLine,那么如果是第二次输入的nextLine,那么nextLine就会录入null
- nextLine()方法的结束符只是Enter键，即nextLine()方法返回的是Enter键之前的所有字符，它是可以得到带空格的字符串的




## 20211217做PAT心得
> M中找N
- 如果是找到一个,删除一个,采用什么??? 可以的话采用Linklist不错
  - 我采用的是M是list,因为核对成功可以删除它
  - 对于找的东西有很多种类,比如字母(26len数组合适),仅仅几个数字(数组),
  
> list的remove
- 它可以remove两种,index和Object,所以基本类型要变对象(Integer,Character)...这样remove准确

> 输出格式
- 使用DecimalFormat方法
  - ` DecimalFormat df = new DecimalFormat("#0.00");`
- 它的使用是截取数,后面几位数如果大于500,则入,如5.55501它会5.56

- System.out.format("%.1f",PI); 会四舍五入


## 20211221做PAT心得
> java中的三角函数
- 关于度数
  - double a = Math.toRadians(90);//把数字90 转换成 90度
- 关于sin,cos 
  - System.out.println(Math.sin(a));//计算sin 90度


## 20211227做PAT心得
> 关于排序，单条件，直接用Utils下的Comparator

> 多条件，在重写时，可以添加判断
- `if(o1.tj1 == o2.tj1){return o1.tj2-o2.tj2;}`
- 字符串的比較`(o1).compareTo(o2);`

## 20220107做PAT心得
> 关于字符串的分割，对于一些特殊符号
- 如[](){}.*#这些符号，他们的前面要使用//，
- 可以使用组合`ss.split("\\) \\(");`
 - 需要每个特殊符号前加//
- **总**：使用特殊符号，前面加//就行。。。

> 在很多时候初始化的值要明确好，加注释，防止后面迷糊了


## 20220126
- 正因数，或称为正约数 ，指的是一个整数中大于0的因数。 如：12的正因数有1，2，3，4，6，12。 因数必须是整数，所以任何整数的最小正因数都是1。
- a整除b是b÷a
- 什么叫整除。。。例如a%b==0  叫a被b整除，换言之b整除a


## 20220209
> treeMap的使用
> 常用于有两个数据要进行排序.
- 今天在treeMap卡了很久，主要原因是我新建java类了，实现的是compare接口，但是我在使用treeMap的过程中并没有给他传输值，仅仅new一个是无法将数据给他的。
> format的out,又忘了//
-  `System.out.format("%.2f",sumPrice);`


## 20220210
> 对于完美数列(M>=mp;)
- 首先明确得是p的值,那么对于M和m来说,两个都是变量.正常操作是不能将其中一个直接锁定为死值的..
- zjz说:首先要明白的是**有几个变量**!

## 20220214
> 对于科学计数法，宇宙无敌加法器
- 很关键的点就是注释，注释让我很快的思路清晰


## 20220216
> 做题时要注意区间是闭合的还是不是闭合的，测试时先通过0，1，2，和最大的


## 20220217
> 对于LMR,左中右指针
- 正常计算M = L+((L+R)>>1); 
- M的取值**偶数**时取左半边的最后一个,**奇数**时取正好中间,所以正常`第二指针`应该是M+1,防止偶数时元素重复


> 解读代码的流程:
- 1.主函数调用哪几个函数
- 2.进入调用的函数,先看入参,出参,(明白大概要干个啥),观看涉及,以及逻辑---注意return...
- 3.循环第二步,注意之前调入函数的入参是否已经是处理过的,最好的方法就是弄个例子一走

> 解读MergeSort
- 1.进入主函数,正常的输入,输出--调用的逻辑是process
- 2.进入process,入参数组.无出参---只做处理--递归结束标志,LMR(左--中,中--右处理),调用merge
- 3.进入merge,入参数组,无出参---只作处理--双指针处理,左和(中+1)指针,为啥中+1,因为进来的是数组.之前除2的时候会直接去中间的前一个


> 归并并不一定要从中间不断分割开归并，也可以2的倍数，3的倍数进行归并


## 20220218
> 在做A除B的时候，对于超长的字符串
- 不要用Scanner进行数据的读入，因为Scanner对输入数据进行正则解析
- 得使用BufferedReader来进行输入


## 20220219
> 算法基础规模在26以下的，优先考虑数组解决
- 1.比如说混乱的数字中要固定的顺序（如：扑克牌）

