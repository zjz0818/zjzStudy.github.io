# DP(dynamic programming)-动态规划
## 简介
> 动态规划算法是解决**多阶段**决策过程最优化问题的一种常用方法
> 
> 关键：递归确实是从上而下的运行，但是所得的结果确实从下而上来的。-
> 
> 所以该考虑的是从下而上的运行。

### 定义
> 决策：
- 决策--决定的策略或办法---确定干还是不干，叫`决`；`明确用什么方法和工具干，叫策`。决策，就是做出用什么工具和方法去达成什么目标的难以逆转的决定。
  
> 基本思想：
- 动态规划算法的基本思想是：
  - 1.将待求解的问题**分解**成若干个`相互联系`的子问题，先求解子问题，然后从这些子问题的解得到原问题的解；
  - 2.对于重复出现的子问题，只在第一次遇到的时候对它进行求解，并把答案保存起来，让以后再次遇到时直接引用答案，不必重新求解。
  - 3.动态规划算法将问题的解决方案视为一系列决策的结果，与贪婪算法不同的是，在贪婪算法中，每采用一次贪婪准则，便做出一个不可撤回的决策；
    而在动态规划算法中，还要考察每个最优决策序列中是否包含一个最优决策子序列，即问题是否具有最优子结构性质。

> 注意:
- 值得关注的是：题上会很明显的指出决策的，也会很明显的指出子问题与子问题之间的联系。
  - 这种题最为**关键的特征**就是，当前子问题与**其他**（一般都是多个）之间有关系。
- 题上如果与1,2有关的大部分就是dp(x-1),dp(x-2)。 ---这个不是重点

> 基本做法：
> 
> 三角型系列
> 
- ```
    样例1：数字三角形问题
    7
    3 8
    8 1 0
    2 7 4 4
    4 5 2 6 5
  下图给出了一个数字三角形，请编写一个程序，计算从顶至底的某处的一条路径，使该路径所经过的数字和最大,从顶部向下走，每次只能走下面或者右下
  ```
- 流程：--
  - 1.分析问题的最优解，找出最优解的性质，并刻画其结构特征：
    - 问题的最优解：所有走法中最大的权值是多少？
    - 最优解的性质和结构特征：只能向正下或者右下走，每走一行的最大权值等于前面一行的最大权值加上这一行的走的两个方向中的最大值
  - 2.2.递归的定义最优值：
    - 要找到从0行出发的最优值，就要找到从第1行出发的最优值
    - 要找到从1行出发的最优值，就要找到从第2行出发的最优值
    - ………………………
    - 要找到第3行出发的最优值，就要找到从最后一行出发的最优值
  - 所以是由上而下的运行，结果由下而上的回溯。重点关注的是由下而上的回溯
  - 我们需要递归求解，要先求解从倒数第一行出发的最优值，然后根据从倒数第一行出发的最优值求出从倒数第二行出发的最优值
  - 3.根据计算最优值时间得到的信息，构造最优解4.根据计算最优值时间得到的信息，构造最优解  
    - 这个就是问你具体是怎么走的，我们需要在求解子问题的时候保存一些信息，采用构造出最优解
      （最优值和最优解是不同的，最优值在本问题中是一个走法中权值之和最大的那一个，而最优解是具体的走法），

> LCS系列
- 何为LCS问题：
  在求解LCS问题之前，我们需要先了解一下什么叫做最长公共子序列
  最长公共子序列：用我们最容易通俗理解的话语来解释的话，最长公共子序列就是两个或者多个串中，最长的相同的子序列
  ps：子序列可以不连续，但是有先后的次序关系

-     
- `dp[i][j] = dp[i-1][j-1]+1;`  // 保证前面匹配到的值加到当前匹配节点
- `dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);`  
  // 保证程序的正常走向，不管是横着还是竖着，有值就应该一直记录着，且为上左的最大，同时取最大是为了最大子序列，不加可能取的小序列
  
- ```
    dp[i] == dp[j]; dp[i][j] = dp[i-1][j-1] + 1;    
    dp[i] != dp[j]; dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
  ```


- zjz：我该明白的是，为啥要使用二维数组来将它进行统计。而且他可以将所有情况考虑到。
  - 明白二维数组不难，本来就是要走统计的，明白横竖也不难，本来就该记录的。
  - 关键是对角线的取值以及max问题---对角线确实可以将之前所遇到的元素进行叠加。




- zjz说：之前使用递归，专门学习的，是为了解决单点问题，单个元素抽出来的问题。
  
- 之前的最大的子序列合，最长递增序列，最长对称数
  - 解决思路都是，递归解决：单个元素的角度出发，尽可能大的去匹配。---都是如果有，下个元素进行递归，给一个由上而下的动力，再由下而上的回溯值。
  - 再由主函数时的遍历就行。
    - 在我之前的解决中，子问题的联系也就是进入下次递归的条件。
    - 重复项是通过数组记录的方式进行解决的
  

> DP与贪心
- dp和贪心的不同之处在于每一次的贪心都是做出不可撤回的决策（即每次局部最优），而在dp中还有考察
  每个最优决策子序列中是否包含最优决策子序列，即是否具有最优子结构性质，贪心中每一步都
  只顾眼前
  最优，并且当前的选择是不会依赖以前的选择的，而dp，在选择的时候是从以前求出的若干个与本步骤
  相关的子问题中选最优的那个，加上这一步的值来构成这一步那个子问题的最优解
