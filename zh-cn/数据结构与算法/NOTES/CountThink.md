# 将一些常见的算法思维记录

> 算法解题步骤:---算法本就是一个个小组件组合而成,所以要先拆!
> 
> 1.找到最基本的单元--比如单轮跑,---直接模拟流程走一波单轮,写出来
> 
> 2.在最基本的上面再做运算
> 
> 3.优化
> 
> 测试:自测:自制样本产生器(关键,要全面),自编两种方法,或者需要到已有的方法,两个同时运行,比较
> 

## 关键明白:
- 算法特性：有穷，确定，可行，输入，输出
- 好算法: 正确性，可读性，健壮性（非法），高效率，低存储

## zjz以后的操作:-定,解,约束
- 定:目标
- 解:解题思路  
- 约束:每次做题,正常编写--先写注释:输入,输出,正确性,健壮性-->高效率--五要素
- 最后满足条件再删除(核查)

### -------------------------------------------------思想----------------------------------------------------------------
# 一.图形思想
## 一.1.判断
- 如果判断的元素多于两个,那么开始使用数轴
- 如果判断的涉及多余一个,那么考虑边界(内外!!!)

## 一.2.对于一些数,集合什么的
- 要有xy形式的图,遇到就画!!


# 二.有效性,无效性思想
## 二.1.放弃杂物,只要有用的
- 如一个数轴上L-R的中间数,正常计算为(L+R)/2
- 而我们要放弃L左边的距离,只关注L与R的关系,,,L+(R-L)/2---达成思路清晰!


## 二.2.增益,负增益
- 增益:指的是我们如果要去求一些区间的**最大值**时,我们考虑的第一个应该是增益
- 如果增益有效,继续,增益无效则放弃
  - 注意要判断好前增益,后增益,前增益为负时应该放弃了,后增益完为负时,应该跳过到下一个正的
- 当然还需一个计数器

- 举例:最大子序和





### -------------------------------------------------------思想结束-------------------------------------------------------


## 基本排序  
- -代码在gitee上 study-demo/ src / com / Algorithm / Study / ThinkTest
- n^2的
  - 死流程--数据状况不会影响复杂度
    - 选择 --位置选最小--
    - 冒泡 -- 两两交换,得出
  - 活的--数据状况影响复杂度
    - 插入---条件发生,区间排序移动
    - 思想:保证:0-1 0-2 0-3 0-4 0-...有序


## 思想
> 要想拥有一个动态的固定值,,,试着用(固定值+X) - X = 固定值   ---基本的用法,加一个数,在减一个数,等式不变
> 


## 指针思想!!!
> 指针思想必须有
> 
- 指针思想一般用来指要进行的下一步,或者要卡死的值,或者卡区间
  
- 区间指针for---必须形成肌肉记忆
  - for(int i = 0; i< len;i++)        -----这里面区间指针[0,len) 右边取决于`<`或`>`就是`)`  有等于就是`]`

- zjz思考
  - 以后对于for操作,直接第一眼明白要卡哪,以后做题,第一眼要明白我想卡哪里



## 滑动窗口--`{ [---] }`
> 一般用于解决重复,或者搜寻指定的玩意
> 滑块的本质就是外层i控制长度,内层j不断变,进而形成一个块
- 死板的滑动窗口--O低--推荐使用
  - 即窗口大小固定(暂时固定),然后可以移动,搜寻值 --- 它正常的运行是这样的-左右括号不动,块一直跑
    - 两头卡住,窗口移动--类似于一个窗口跑来跑去...跑完一波,窗口变小(或变大)
    - 如果是15的长度的话,最坏1+2+3+4+5+...的运行次数
  - 之所以用它,是因为它可以从一开始就卡长度

- zjz的思想;
  - 使用外部定块
  - 内部移动块 --- 注意是i+j<len,,因为是一个块[]  ,所以整体块的末尾得小于数组,防止移出去
  - 关键是长度动态的变化,需两个量控制
  -

```
  for (int i = 0; i < len; i++) {     // 定块大小
            for (int j = 0; i+j < len; j++) { // 移动块
            // 启动滑块 [j] [i+j]
            
            }}


```

  


- 活动的滑动窗口--O高
  - 即它是一个窗口,但是这个窗口可能由[m,n]的变化 它正常的运行是这样的-左括号一直跑,右括号由外控制
    - 两头是动的,
    - 有很多重复型动作,每次从头跑的尾,
    - 为啥这么多重复,直接从头跑到尾一次不行吗?? -- 思考:如果是15的长度,跑一次能拿到[1,14]吗????所以右栏也得动..
    - 如果是15的话,,,最坏15+14+13+11+....的运行次数
    
- 解释:







## 二分思想!!!
- 并非有序数中找.
- 有需求就可使





















## 图形思想
- 曲线:
- 关键:两值可确定一个向上,向下的趋势,
  - 最大,最小  
  - 如果边界从左走是由大变小,从右走由大变小  那么中间必有局部最小,局部最大
  - 如果边界从左走是由小变大,从右走由小变大  那么中间必有局部最小,局部最大






